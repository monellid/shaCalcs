package org.opensha.sha.calc.groundMotionField;

import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.StringTokenizer;

import org.opensha.commons.data.Site;
import org.opensha.commons.geo.Location;
import org.opensha.sha.earthquake.EqkRupture;
import org.opensha.sha.imr.ScalarIntensityMeasureRelationshipAPI;
import org.opensha.sha.imr.param.OtherParams.SigmaTruncLevelParam;
import org.opensha.sha.imr.param.OtherParams.SigmaTruncTypeParam;
import org.opensha.sha.imr.param.OtherParams.StdDevTypeParam;

import com.vladium.emma.report.SrcFileItem;

public class GroundMotionFieldCalculator {

	/**
	 * Computes mean ground motion
	 * 
	 * @param attenRel
	 * @param rup
	 * @param sites
	 * @return
	 */
	public static Map<String, Double> getMeanGroundMotionField(
			ScalarIntensityMeasureRelationshipAPI attenRel, EqkRupture rup,
			List<Site> sites) {
		Map<String, Double> groundMotionMap = new HashMap<String, Double>();
		double meanGroundMotion = Double.NaN;
		attenRel.setEqkRupture(rup);
		System.out.println("QUOOOOOOOOOO");
		for (Site site : sites) {
			System.out.println("QUIIIIIIII");
			attenRel.setSite(site);
			meanGroundMotion = attenRel.getMean();
			groundMotionMap.put(site.getLocation().getLatitude()+"_"+site.getLocation().getLongitude(), new Double(meanGroundMotion));
		}
		return groundMotionMap;
	}

	/**
	 * Compute stochastic ground motion field
	 * 
	 * @param attenRel
	 * @param rup
	 * @param sites
	 * @param rn
	 * @return
	 */
	public static Map<String, Double> getStochasticGroundMotionField(
			ScalarIntensityMeasureRelationshipAPI attenRel, EqkRupture rup,
			List<Site> sites, Random rn) {
		Map<String, Double> stochasticGroundMotionField = new HashMap<String, Double>();
		Map<String, Double> meanGroundMotionField = getMeanGroundMotionField(
				attenRel, rup, sites);
		attenRel.setEqkRupture(rup);
		double standardDeviation = Double.NaN;
		double truncationLevel = (Double) attenRel.getParameter(
				SigmaTruncLevelParam.NAME).getValue();
		String truncationType = (String) attenRel.getParameter(
				SigmaTruncTypeParam.NAME).getValue();
		Iterator<String> iter = meanGroundMotionField.keySet().iterator();
		StringTokenizer st = null;
		while (iter.hasNext()) {
			String siteString = iter.next();
			st = new StringTokenizer("_");
			Site site = new Site(new Location(Double.parseDouble(st.nextToken()),Double.parseDouble(st.nextToken())));
			attenRel.setSite(site);
			standardDeviation = attenRel.getStdDev();
			Double val = meanGroundMotionField.get(siteString);
			double deviate = getGaussianDeviate(standardDeviation,
					truncationLevel, truncationType, rn);
			val = val + deviate;
			stochasticGroundMotionField.put(siteString, val);
		}
		return stochasticGroundMotionField;
	}

	private static double getGaussianDeviate(double standardDeviation,
			double truncationLevel, String truncationType, Random rn) {
		double dev = Double.NaN;
		if (truncationType
				.equalsIgnoreCase(SigmaTruncTypeParam.SIGMA_TRUNC_TYPE_NONE)) {
			dev = standardDeviation * rn.nextGaussian();
		} else if (truncationType
				.equalsIgnoreCase(SigmaTruncTypeParam.SIGMA_TRUNC_TYPE_2SIDED)) {
			dev = rn.nextGaussian();
			while (dev < -truncationLevel || dev > truncationLevel) {
				dev = rn.nextGaussian();
			}
			dev = dev * standardDeviation;
		} else if (truncationType
				.equalsIgnoreCase(SigmaTruncTypeParam.SIGMA_TRUNC_TYPE_1SIDED)) {
			dev = rn.nextGaussian();
			while (dev > truncationLevel) {
				dev = rn.nextGaussian();
			}
			dev = dev * standardDeviation;
		}
		return dev;
	}

}
