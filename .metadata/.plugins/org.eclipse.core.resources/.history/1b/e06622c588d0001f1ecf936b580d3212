package org.opensha.sha.calc.groundMotionField;

import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Random;

import org.opensha.commons.data.Site;
import org.opensha.sha.earthquake.EqkRupture;
import org.opensha.sha.imr.ScalarIntensityMeasureRelationshipAPI;
import org.opensha.sha.imr.param.OtherParams.SigmaTruncLevelParam;
import org.opensha.sha.imr.param.OtherParams.SigmaTruncTypeParam;

public class GroundMotionFieldCalculator {

	/**
	 * Computes mean ground motion for a list of sites.
	 * 
	 * @param attenRel
	 *            : {@link ScalarIntensityMeasureRelationshipAPI} attenuation
	 *            relationship used for ground motion field calculation
	 * @param rup
	 *            : {@link EqkRupture} earthquake rupture generating the ground
	 *            motion field
	 * @param sites
	 *            : array list of {@link Site} where ground motion values have
	 *            to be computed
	 * @return : {@link Map} associating sites ({@link Site}) and ground motion
	 *         values {@link Double}
	 */
	public static Map<Site, Double> getMeanGroundMotionField(
			ScalarIntensityMeasureRelationshipAPI attenRel, EqkRupture rup,
			List<Site> sites) {
		Map<Site, Double> groundMotionMap = new HashMap<Site, Double>();
		double meanGroundMotion = Double.NaN;
		attenRel.setEqkRupture(rup);
		for (Site site : sites) {
			attenRel.setSite(site);
			meanGroundMotion = attenRel.getMean();
			groundMotionMap.put(site, new Double(meanGroundMotion));
		}
		return groundMotionMap;
	}

	/**
	 * Compute stochastic ground motion field by adding to the mean ground
	 * motion field Gaussian deviates which takes into account the truncation
	 * level and the truncation type.
	 * 
	 * @param attenRel
	 *            : {@link ScalarIntensityMeasureRelationshipAPI} attenuation
	 *            relationship used for ground motion field calculation
	 * @param rup
	 *            : {@link EqkRupture} earthquake rupture generating the ground
	 *            motion field
	 * @param sites
	 *            : array list of {@link Site} where ground motion values have
	 *            to be computed
	 * @param rn
	 *            : {@link Random} random number generator for Gaussian deviate
	 *            calculation
	 * @return: {@link Map} associating sites ({@link Site}) and ground motion
	 *          values {@link Double}
	 */
	public static Map<Site, Double> getStochasticGroundMotionField(
			ScalarIntensityMeasureRelationshipAPI attenRel, EqkRupture rup,
			List<Site> sites, Random rn) {
		Map<Site, Double> stochasticGroundMotionField = new HashMap<Site, Double>();
		Map<Site, Double> meanGroundMotionField = getMeanGroundMotionField(
				attenRel, rup, sites);
		attenRel.setEqkRupture(rup);
		double standardDeviation = Double.NaN;
		double truncationLevel = (Double) attenRel.getParameter(
				SigmaTruncLevelParam.NAME).getValue();
		String truncationType = (String) attenRel.getParameter(
				SigmaTruncTypeParam.NAME).getValue();
		Iterator<Site> iter = meanGroundMotionField.keySet().iterator();
		for (Site site : sites) {
			attenRel.setSite(site);
			standardDeviation = attenRel.getStdDev();
			Double val = meanGroundMotionField.get(site);
			double deviate = getGaussianDeviate(standardDeviation,
					truncationLevel, truncationType, rn);
			val = val + deviate;
			stochasticGroundMotionField.put(site, val);
		}
		return stochasticGroundMotionField;
	}

	/**
	 * Generate Gaussian deviate (mean zero, standard deviation =
	 * standardDeviation)
	 * 
	 * @param standardDeviation
	 *            : double standard deviation
	 * @param truncationLevel
	 *            : double truncation level (in units of standard deviation)
	 * @param truncationType
	 *            : String type of truncation defined by the
	 *            {@link SigmaTruncTypeParam}
	 * @param rn
	 *            : random number generator
	 * @return : double
	 */
	private static double getGaussianDeviate(double standardDeviation,
			double truncationLevel, String truncationType, Random rn) {
		double dev = Double.NaN;
		if (truncationType
				.equalsIgnoreCase(SigmaTruncTypeParam.SIGMA_TRUNC_TYPE_NONE)) {
			dev = standardDeviation * rn.nextGaussian();
		} else if (truncationType
				.equalsIgnoreCase(SigmaTruncTypeParam.SIGMA_TRUNC_TYPE_2SIDED)) {
			dev = rn.nextGaussian();
			while (dev < -truncationLevel || dev > truncationLevel) {
				dev = rn.nextGaussian();
			}
			dev = dev * standardDeviation;
		} else if (truncationType
				.equalsIgnoreCase(SigmaTruncTypeParam.SIGMA_TRUNC_TYPE_1SIDED)) {
			dev = rn.nextGaussian();
			while (dev > truncationLevel) {
				dev = rn.nextGaussian();
			}
			dev = dev * standardDeviation;
		}
		return dev;
	}
	
	private static void validateInput(){
		
	}

}
