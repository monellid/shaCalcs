package org.gem.correlationmodels;

import static org.junit.Assert.assertTrue;

import java.util.List;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.commons.math.linear.BlockRealMatrix;
import org.apache.commons.math.linear.MatrixUtils;
import org.gem.calc.HazardCalculator;
import org.opensha.commons.data.Site;
import org.opensha.commons.geo.LocationUtils;
import org.opensha.sha.earthquake.EqkRupture;
import org.opensha.sha.imr.ScalarIntensityMeasureRelationshipAPI;
import org.opensha.sha.imr.param.IntensityMeasureParams.PeriodParam;
import org.opensha.sha.imr.param.IntensityMeasureParams.SA_Param;
import org.opensha.sha.imr.param.OtherParams.StdDevTypeParam;

/**
 * Defines correlation model from Jayamram & Baker (2009):
 * "Correlation model for spatially distributed ground-motion intensities"
 * Nirmal Jayaram and Jack W. Baker, Earthquake Engng. Struct. Dyn (2009)
 */
public class JB2009 extends CorrelationModel {
	
    private static Boolean Vs30Cluster;
    
    private static Log logger = LogFactory.getLog(HazardCalculator.class);
    
    // minimum correlation value (below this value of correlation, 
    // correlation values are automatically set to 0, to save computation time)
    public static double minCorrelationValue = 1e-5;
    
    /**
     * Creates J&B2009 correlation model
     */
	public JB2009(ScalarIntensityMeasureRelationshipAPI attenRel, EqkRupture rup,
            List<Site> sites, Boolean Vs30Cluster){
	    validateInput(
	            attenRel,
	            rup, sites,
	            Vs30Cluster);
		this.attenRel = attenRel;
		this.rup = rup;
		// sites are sorted with respect to distance to a reference site to make
		// covariance matrix calculation faster (in this way as soon as 
		// a site produce a correlation value smaller than 
		// minCorrelationValue, then also the subsequent sites will have a
		// smaller or equal correlation value and therefore can be skipped)
		List<Site> sortedSite = null;
		for(int i=0;i<sites.size();i++){
			CorrelationModelsHelper.orderSites(sites, sites.get(0));
			sortedSite.add(sites.get(0));
		}
		for(Site site : sites){
			CorrelationModelsHelper.orderSites(sites, site);	
		}
	     for (int i=0;i<sites.size()-2;i++) {
		       double dist1 =
		               LocationUtils.horzDistance(sites.get(i).getLocation(), sites.get(i+1).getLocation());
		       double dist2 =
	               LocationUtils.horzDistance(sites.get(i+1).getLocation(), sites.get(i+2).getLocation());
		       System.out.println(dist1+" "+dist2);
		     }
		this.sites = sites;
		this.Vs30Cluster = Vs30Cluster;
	}

	@Override
	/**
	 * Get covariance matrix 
	 */
	public BlockRealMatrix getCovarianceMatrix() {
        int numberOfSites = sites.size();
        BlockRealMatrix covarianceMatrix =
                (BlockRealMatrix)MatrixUtils.createRealIdentityMatrix(numberOfSites);
        attenRel.setEqkRupture(rup);
        attenRel.getParameter(StdDevTypeParam.NAME).setValue(
                StdDevTypeParam.STD_DEV_TYPE_INTRA);

        // default value for period is zero. Only if spectral acceleration
        // calculation is requested, the value of the period variable is
        // obtained from the attenRel object
        double period = 0.0;
        if (attenRel.getIntensityMeasure().getName()
                .equalsIgnoreCase(SA_Param.NAME)) {
            period =
                    (Double) attenRel.getParameter(PeriodParam.NAME).getValue();
        }

        double correlationRange = Double.NaN;
        if (period < 1 && Vs30Cluster == false)
            correlationRange = 8.5 + 17.2 * period;
        else if (period < 1 && Vs30Cluster == true)
            correlationRange = 40.7 - 15.0 * period;
        else if (period >= 1)
            correlationRange = 22.0 + 3.7 * period;
        double intraEventStd_i = Double.NaN;
        double intraEventStd_j = Double.NaN;
        double distance = Double.NaN;
        double correlationValue = Double.NaN;
        double covarianceValue = Double.NaN;

        logger.debug("Computing covariance matrix...");
        long start = System.currentTimeMillis();
        for (int i = 0; i < sites.size(); i++) {
            System.out.println("Raw: " + (i + 1) + " of " + numberOfSites);
            Site site_i = sites.get(i);
            attenRel.setSite(site_i);
            intraEventStd_i = attenRel.getStdDev();
            for (int j = i; j < sites.size(); j++) {
                Site site_j = sites.get(j);
                attenRel.setSite(site_j);
                intraEventStd_j = attenRel.getStdDev();
                distance =
                        LocationUtils.horzDistance(site_i.getLocation(),
                                site_j.getLocation());
                correlationValue = Math.exp(-3 * (distance / correlationRange));
                // if correlation value is too small, break current loop 
                // covariance values are already set to zero given that the 
                // covariance matrix is initialized as an identity matrix
                // this allows saving computation time
                System.out.println("Correlation value: "+correlationValue);
                if(correlationValue<minCorrelationValue){
                	break;
                }
                covarianceValue =
                        intraEventStd_i * intraEventStd_j
                                * correlationValue;
                covarianceMatrix.setEntry(i, j, covarianceValue);
                covarianceMatrix.setEntry(j, i, covarianceValue);
            }
        }
		long elapsedTimeMillis = System.currentTimeMillis() - start;
        float elapsedTimeSec = elapsedTimeMillis / 1000F;
        float elapsedTimeMin = elapsedTimeMillis / (60 * 1000F);
        logger.debug("End computing covariance matrix.");
        logger.debug("Elapsed time (sec): " + elapsedTimeSec);
        logger.debug("Elapsed time (min): " + elapsedTimeMin + "\n");

        return covarianceMatrix;
	}
	
    private static void
    validateInput(
            ScalarIntensityMeasureRelationshipAPI attenRel,
            EqkRupture rup, List<Site> sites,Boolean Vs30Cluster) {
        if (attenRel == null) {
            throw new IllegalArgumentException(
                    "Attenuation relationship cannot be null");
        }

        if (rup == null) {
            throw new IllegalArgumentException(
                    "Earthquake rupture cannot be null");
        }

        if (sites == null) {
            throw new IllegalArgumentException(
                    "Array list of sites cannot be null");
        }

        if (sites.isEmpty()) {
            throw new IllegalArgumentException(
                    "Array list of sites must contain at least one site");
        }
		if (Vs30Cluster == null) {
		    throw new IllegalArgumentException(
		            "Vs30 cluster option must be specified");
		}
		if (attenRel.getParameter(StdDevTypeParam.NAME).getConstraint()
		        .isAllowed(StdDevTypeParam.STD_DEV_TYPE_INTRA) == false) {
		    throw new IllegalArgumentException(
		            "The specified attenuation relationship does not provide"
		                    + " intra-event standard deviation");
		}
    }
}
