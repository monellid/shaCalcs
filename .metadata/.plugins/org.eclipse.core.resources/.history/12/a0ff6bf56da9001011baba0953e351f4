package processor;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

import parser.LogicTreeNode;
import tree.Node;
import tree.Tree;

public class LogicTreeProcessor {

	public LogicTreeProcessor() {

	}

	/**
	 * Checks that children of a node have weights that sum to 1.
	 */
	public Boolean hasValidWeights(Tree<LogicTreeNode> tree) {
		Boolean isValid = true;
		List<Node<LogicTreeNode>> nodeList = tree.toList();
		for (Node<LogicTreeNode> node : nodeList) {
			if (!node.getChildren().isEmpty()) {
				double weigth = 0.0;
				for (Node<LogicTreeNode> child : node.getChildren()) {
					weigth = weigth + child.data.getUncertaintyWeight();
				}
				if (weigth != 1.0) {
					isValid = false;
					break;
				}
			}
		}
		return isValid;
	}

	/**
	 * Computes all logic tree paths from the root node. Algorithm taken and
	 * adapted from http://cslibrary.stanford.edu/110/BinaryTrees.html#java
	 * (printPaths() solution)
	 */
	public List<LogicTreePath> computeAllLogicTreePaths(Tree<LogicTreeNode> tree) {
		List<LogicTreePath> logicTreePaths = new ArrayList<LogicTreePath>();
		List<LogicTreeNode> path = new ArrayList<LogicTreeNode>();
		int pathLen = 0;
		computeAllLogicTreePaths(tree.getRootElement(), path, pathLen,
				logicTreePaths);
		return logicTreePaths;
	}

	/**
	 * Compute all logic tree paths in a recursive way.
	 */
	private void computeAllLogicTreePaths(Node<LogicTreeNode> node,
			List<LogicTreeNode> path, int pathLen,
			List<LogicTreePath> logicTreePaths) {
		if (node == null)
			return;

		if (path.size() <= pathLen) {
			path.add(pathLen, node.data);
		} else {
			path.set(pathLen, node.data);
		}
		pathLen = pathLen + 1;

		if (node.getChildren().isEmpty()) {
			// create LogicTreePath and add to logicTreePaths
			List<LogicTreeNode> nodeList = new ArrayList<LogicTreeNode>();
			double pathWeight = 1;
			for (int i = 0; i < pathLen; i++) {
				nodeList.add(path.get(i));
				pathWeight = pathWeight * path.get(i).getUncertaintyWeight();
			}
			LogicTreePath p = new LogicTreePath(nodeList, pathWeight);
			logicTreePaths.add(p);
		} else {
			for (Node<LogicTreeNode> n : node.getChildren()) {
				computeAllLogicTreePaths(n, path, pathLen, logicTreePaths);
			}
		}

	}

	/**
	 * Randomly sample n logic tree paths.
	 */
	public List<LogicTreePath> sampleLogicTreePaths(
			Tree<LogicTreeNode> logicTree, Random rn, int n) {
		List<LogicTreePath> logicTreePaths = new ArrayList<LogicTreePath>();
		for (int i = 0; i < n; i++) {
			List<LogicTreeNode> nodeList = new ArrayList<LogicTreeNode>();
			double pathWeight = 1;
			sampleLogicTreePath(logicTree.getRootElement(), rn, nodeList, pathWeight);
		}
		return logicTreePaths;
	}

	private LogicTreePath sampleLogicTreePath(Node<LogicTreeNode> node, Random rn) {
		if (node.getChildren().isEmpty()) {
			List<LogicTreeNode> nodeList = new ArrayList<LogicTreeNode>();
			nodeList.add(node.getData());
			LogicTreePath path = new LogicTreePath(nodeList, node.getData()
					.getUncertaintyWeight());
			return path;
		}
		else{
			List<LogicTreeNode> nodeList = new ArrayList<LogicTreeNode>();
			// get list of children and randomly select one of these
			List<Node<LogicTreeNode>> children = node.getChildren();
			// define probability mass function
			double[] prob = new double[children.size()];
			LogicTreeNode[] x = new LogicTreeNode[children.size()];
			for(int i=0;i<children.size();i++){
				x[i] = children.get(i).getData();
				prob[i] = children.get(i).getData().getUncertaintyWeight();
			}
			// generate uniform random number between 0 and 1
			Node<LogicTreeNode> sampledNode = null;
			double u = rn.nextDouble();
			double p = 0;
			for(int j=0;j<x.length;j++){
				p = p + prob[j];
				if(u<=p){
					sampledNode = new Node<LogicTreeNode>(x[j]);
					break;
				}
			}
			sampleLogicTreePath(sampledNode,rn);
		}
	}

	// /**
	// * Sample a logic tree path starting from node n in a recursive way.
	// */
	// private void sampleLogicTreePath(Tree<LogicTreeNode> logicTree,
	// Node<LogicTreeNode> node, List<LogicTreeNode> path, int pathLen,
	// Random rn, List<LogicTreePath> logicTreePaths) {
	//
	// if (node == null)
	// return;
	//
	// // randomly select node
	//
	//
	// if (path.size() <= pathLen) {
	// path.add(pathLen, node.data);
	// } else {
	// path.set(pathLen, node.data);
	// }
	// pathLen = pathLen + 1;
	//
	// }

	//
	// /**
	// * Join multiple logic trees.
	// */
	// public Tree<LogicTreeNode> joinLogicTrees(List<Tree<LogicTreeNode>>
	// treeList) {
	// Tree<LogicTreeNode> newTree = null;
	// return newTree;
	// }
}